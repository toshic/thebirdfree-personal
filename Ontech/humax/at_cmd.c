/*
    Warning - this file was autogenerated by genparse
    DO NOT EDIT - any changes will be lost
*/

#include "at_cmd.h"
#include "uart.h"
#include "WritePSKey.h"
#include "headset_a2dp_connection.h"

#include <ctype.h>
#include <codec.h>
#include <panic.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <util.h> /* hash and compare */
#include <bdaddr.h>

#if (defined TEST_HARNESS || defined DISPLAY_UART_CMDS)
#include <stdio.h>
#endif

typedef const uint8 *ptr;

static ptr parseData(ptr s, ptr e, Task task);

static __inline__ char my_toupper(char c)
{ return 'a' <= c && c <= 'z' ? c +'A'-'a' : c; }

static ptr skip1(ptr s, ptr e)
{
  if(s)
    while(s != e && (*s == ' ' || *s == '\t'))
      ++s;
  return s;
}

static ptr match1(ptr s, ptr e)
{ return s && s != e && (*s == '\r' || *s == '\n') ? s+1 : 0; }

#ifdef TEST_HARNESS
static void printString(const char *name, const struct sequence *s)
{
  uint16 i;
  printf(" %s='", name);
  for(i = 0; i < s->length; ++i) putchar(s->data[i]);
  printf("'");
}
#endif

static __inline__ ptr skipQuote(ptr p, ptr e)
{ return p && p != e && *p == '"' ? p+1 : p; }

static const int isStringTable[] =
{
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,
    1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0
};

static __inline__ int isString(char c)
{
    return (c & ~0x7F) == 0 && isStringTable[(int)c];
}

static ptr getString(ptr p, ptr e, struct sequence *res)
{
  p = skipQuote(p, e);
  if(p)
  {
    ptr s = p;
    while(p != e && isString(*p)) ++p;
    if(p != s)
    {
        res->data = s;
        res->length = p - s;
        return skipQuote(p, e);
    }
    else
    {
        p = skipQuote(p, e);
        if (*p==',' || *p == '\r')
        {
            res->data = 0;
            res->length = 0;
            return p;
        }
    }
  }
  res->data = 0;
  res->length = 0;
  return 0;
}

static ptr getWildString(ptr p, ptr e, struct sequence *res)
{
  if(p)
  {
    ptr s = p;
    p = (uint8*)UtilFind(0xFFFF, '\r', (const uint16*)p, 0, 1, (uint16) (e - p));
    if (!p) p = (uint8*)UtilFind(0xFFFF, '\n', (const uint16*)p, 0, 1, e - p);
    if (!p) p = e;
    res->data = s;
    res->length = p - s;
    return p;
  }
  res->data = 0;
  res->length = 0;
  return 0;
}

static ptr findEndOfPacket(ptr s, ptr e)
{
  /*
     Returns
     0   if the buffer holds an incomplete packet
     s+1 if the buffer holds an invalid packet
     end of the first packet otherwise
  */
  if(s == e) return 0;

  if(*s == '\r')
  {
    /* expecting <cr> <lf> ... <cr> <lf> */
    if(e-s >= 4)
    {
      if(s[1] == '\n' && s[2] != '\r')
      {
        ptr p = s+2;
        if(*p != '\r')
        {
#ifndef TEST_HARNESS
        p = (const uint8*)UtilFind(0xFFFF, '\r', (const uint16*)p, 0, 1, (uint16)(e-p));
#endif
#ifdef TEST_HARNESS
		   while(p != e && *p != '\r') p++;
#endif
        return p == 0 || p + 1 == e ? 0 /* no terminator yet */
             : p[1] == '\n' ? p+2 /* valid */
             : s+1 ; /* invalid terminator */
         }
         else
             return s+1;
      }
      else
      {
        return s+1;
      }
    }
    else
    {
      /* Can't tell yet */
      return 0;
    }
  }
  else
  {
    /* expecting ... <cr> */
    ptr p = s;
    while(p != e && (*p == ' ' || *p == '\n' || *p == '\0' || *p == '\t')) ++p;
    if(p != e && *p == '\r') return s+1;
    while(p != e && *p != '\r') ++p;
    return p == e ? 0 : p+1;
  }
}

#ifndef TEST_HARNESS
#ifdef __XAP__
uint16 parseUart(Source uart, Task task)
{
  ptr s = SourceMap(uart);
  ptr e = s + SourceSize(uart);
  ptr p = parseData(s, e, task);
  if(p != s)
  {
    SourceDrop(uart, (uint16) (p - s));
    return 1;
  }
  else
  {
    return 0;
  }
}
#endif
#endif

typedef struct {
  char c;
  int to;
} Arc;

static const Arc arcs[] = {
  { '\t', 0 },
  { ' ', 0 },
  { 'A', 1 },
  { 'T', 2 },
  { '\t', 2 },
  { ' ', 2 },
  { '+', 3 },
  { '\t', 3 },
  { ' ', 3 },
  { 'M', 4 },
  { 'R', 5 },
  { 'S', 6 },
  { 'V', 7 },
  { 'W', 8 },
  { 'C', 9 },
  { 'D', 10 },
  { 'P', 11 },
  { 'R', 12 },
  { 'S', 13 },
  { 'D', 14 },
  { 'C', 15 },
  { 'P', 16 },
  { 'T', 17 },
  { 'G', 18 },
  { 'R', 19 },
  { 'O', 20 },
  { 'S', 21 },
  { 'L', 22 },
  { 'S', 23 },
  { 'P', 24 },
  { 'B', 25 },
  { 'N', 26 },
  { 'S', 27 },
  { 'A', 28 },
  { 'I', 29 },
  { 'A', 30 },
  { 'M', 31 },
  { 'S', 32 },
  { 'N', 33 },
  { 'N', 34 },
  { 'C', 35 },
  { 'Y', 36 },
  { 'T', 37 },
  { 'D', 38 },
  { 'D', 39 },
  { 'M', 40 },
  { 'S', 41 },
  { 'N', 42 },
  { 'N', 43 },
  { 'T', 44 },
  { '\t', 31 },
  { ' ', 31 },
  { ':', -1 },
  { '=', -1 },
  { '\t', 32 },
  { ' ', 32 },
  { ':', -2 },
  { '=', -2 },
  { 'M', 45 },
  { '\t', 34 },
  { ' ', 34 },
  { ':', -3 },
  { '=', -3 },
  { '\t', 35 },
  { '\n', -4 },
  { '\r', -4 },
  { ' ', 35 },
  { '\t', 36 },
  { '\n', -5 },
  { '\r', -5 },
  { ' ', 36 },
  { '\t', 37 },
  { '\n', -6 },
  { '\r', -6 },
  { ' ', 37 },
  { '\t', 38 },
  { '\n', -7 },
  { '\r', -7 },
  { ' ', 38 },
  { '\t', 39 },
  { '\n', -8 },
  { '\r', -8 },
  { ' ', 39 },
  { '\t', 40 },
  { '\n', -9 },
  { '\r', -9 },
  { ' ', 40 },
  { '\t', 41 },
  { '\n', -10 },
  { '\r', -10 },
  { ' ', 41 },
  { '\t', 42 },
  { ' ', 42 },
  { ':', -11 },
  { '=', -11 },
  { '\t', 43 },
  { ' ', 43 },
  { ':', -12 },
  { '=', -12 },
  { '\t', 44 },
  { ' ', 44 },
  { ':', 46 },
  { '=', 46 },
  { '\t', 45 },
  { ' ', 45 },
  { ':', -13 },
  { '=', -13 },
  { '\t', 46 },
  { '\n', -14 },
  { '\r', -14 },
  { ' ', 46 },
  { '?', 47 },
  { '\t', 48 },
  { '\n', -14 },
  { '\r', -14 },
  { ' ', 48 },
  { '?', 47 },
  { '\t', 48 },
  { '\n', -14 },
  { '\r', -14 },
  { ' ', 48 },
};

static const Arc *const states[50] = {
  &arcs[0],
  &arcs[3],
  &arcs[4],
  &arcs[7],
  &arcs[14],
  &arcs[19],
  &arcs[20],
  &arcs[23],
  &arcs[24],
  &arcs[25],
  &arcs[26],
  &arcs[27],
  &arcs[28],
  &arcs[29],
  &arcs[30],
  &arcs[33],
  &arcs[34],
  &arcs[35],
  &arcs[36],
  &arcs[38],
  &arcs[39],
  &arcs[40],
  &arcs[41],
  &arcs[42],
  &arcs[43],
  &arcs[44],
  &arcs[45],
  &arcs[46],
  &arcs[47],
  &arcs[48],
  &arcs[49],
  &arcs[50],
  &arcs[54],
  &arcs[58],
  &arcs[59],
  &arcs[63],
  &arcs[67],
  &arcs[71],
  &arcs[75],
  &arcs[79],
  &arcs[83],
  &arcs[87],
  &arcs[91],
  &arcs[95],
  &arcs[99],
  &arcs[103],
  &arcs[107],
  &arcs[112],
  &arcs[117],
  &arcs[121],
};

static uint16 matchLiteral(ptr s, ptr e, Task task)
{ s=s; e=e; task=task; return 0; }

static ptr parseData(ptr s, ptr e, Task task)
{
  ptr p;

#ifdef DISPLAY_UART_CMDS
  {
  	ptr c = s;
    printf("\nreceived: ");
  	while (c != e)
  	{
		if (*c == '\r')			printf("\\r");
		else if (*c == '\n') 	printf("\\n");
		else 					putchar(*c);

		c++;
  	}
  }
#endif

#ifdef TEST_HARNESS
  task = task;
#endif
  for(; (p = findEndOfPacket(s, e)) != 0; s = p)
  {
    if(p == s+1)
    {
      /* Silently discard one character; no packets are that short */
      continue;
    }
    else if(matchLiteral(s, p, task))
    {
      continue;
    }
    else
    {
      union {
        struct set_volume_microphone set_volume_microphone;
        struct set_volume_speaker set_volume_speaker;
        struct a2dp_signal_connect_req a2dp_signal_connect_req;
        struct set_scan_mode set_scan_mode;
        struct write_pin write_pin;
        struct write_local_name write_local_name;
      } u, *uu = &u;
      int state = 0;
      ptr t = s;
      while(t != e && state >= 0)
      {
        char m = my_toupper((char) *t);
        const Arc *a = states[state];
        const Arc *const last_a = states[state+1];
#ifndef TEST_HARNESS
        a = (const Arc *) (void *) UtilFind(0xFFFF, (uint16) m, (const uint16 *) (void *) &a[0].c, 0, sizeof(Arc), (uint16) (last_a - a));
#endif
#ifdef TEST_HARNESS
        while(a != last_a && a->c != m) a++;
#endif
        /*lint -e{801} suppress goto is deprecated */
        if(!a) goto unrecognised;
        state = a->to;
        ++t;
      }
      switch(-state)
      {
        case 1:
          if(match1(skip1(UtilGetNumber(skip1(t, e), e, &uu->set_volume_microphone.volume), e), e))
          {
#ifndef TEST_HARNESS
            set_volume_microphone(task, &uu->set_volume_microphone);
#endif
#ifdef TEST_HARNESS
            printf("Called set_volume_microphone");
            printf(" volume=%d", uu->set_volume_microphone.volume);
            putchar('\n');
#endif
            continue;
          }
          break;
        case 2:
          if(match1(skip1(UtilGetNumber(skip1(t, e), e, &uu->set_volume_speaker.volume), e), e))
          {
#ifndef TEST_HARNESS
            set_volume_speaker(task, &uu->set_volume_speaker);
#endif
#ifdef TEST_HARNESS
            printf("Called set_volume_speaker");
            printf(" volume=%d", uu->set_volume_speaker.volume);
            putchar('\n');
#endif
            continue;
          }
          break;
        case 3:
          if(match1(skip1(getString(skip1(t, e), e, &uu->a2dp_signal_connect_req.bdaddr), e), e))
          {
#ifndef TEST_HARNESS
            a2dp_signal_connect_req(task, &uu->a2dp_signal_connect_req);
#endif
#ifdef TEST_HARNESS
            printf("Called a2dp_signal_connect_req");
            printString("bdaddr", &uu->a2dp_signal_connect_req.bdaddr);
            putchar('\n');
#endif
            continue;
          }
          break;
        case 4:
          if(t)
          {
#ifndef TEST_HARNESS
            a2dp_signal_disconnect_req(task);
#endif
#ifdef TEST_HARNESS
            printf("Called a2dp_signal_disconnect_req");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 5:
          if(t)
          {
#ifndef TEST_HARNESS
            a2dp_start_req(task);
#endif
#ifdef TEST_HARNESS
            printf("Called a2dp_start_req");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 6:
          if(t)
          {
#ifndef TEST_HARNESS
            master_reset(task);
#endif
#ifdef TEST_HARNESS
            printf("Called master_reset");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 7:
          if(t)
          {
#ifndef TEST_HARNESS
            a2dp_suspend_req(task);
#endif
#ifdef TEST_HARNESS
            printf("Called a2dp_suspend_req");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 8:
          if(t)
          {
#ifndef TEST_HARNESS
            read_local_bdaddr(task);
#endif
#ifdef TEST_HARNESS
            printf("Called read_local_bdaddr");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 9:
          if(t)
          {
#ifndef TEST_HARNESS
            read_remote_name(task);
#endif
#ifdef TEST_HARNESS
            printf("Called read_remote_name");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 10:
          if(t)
          {
#ifndef TEST_HARNESS
            read_remote_rssi(task);
#endif
#ifdef TEST_HARNESS
            printf("Called read_remote_rssi");
            putchar('\n');
#endif
            continue;
          }
          break;
        case 11:
          if(match1(skip1(UtilGetNumber(skip1(t, e), e, &uu->set_scan_mode.mode), e), e))
          {
#ifndef TEST_HARNESS
            set_scan_mode(task, &uu->set_scan_mode);
#endif
#ifdef TEST_HARNESS
            printf("Called set_scan_mode");
            printf(" mode=%d", uu->set_scan_mode.mode);
            putchar('\n');
#endif
            continue;
          }
          break;
        case 12:
          if(match1(skip1(getString(skip1(t, e), e, &uu->write_pin.pin), e), e))
          {
#ifndef TEST_HARNESS
            write_pin(task, &uu->write_pin);
#endif
#ifdef TEST_HARNESS
            printf("Called write_pin");
            printString("pin", &uu->write_pin.pin);
            putchar('\n');
#endif
            continue;
          }
          break;
        case 13:
          if(match1(skip1(getWildString(skip1(t, e), e, &uu->write_local_name.name), e), e))
          {
#ifndef TEST_HARNESS
            write_local_name(task, &uu->write_local_name);
#endif
#ifdef TEST_HARNESS
            printf("Called write_local_name");
            printString("name", &uu->write_local_name.name);
            putchar('\n');
#endif
            continue;
          }
          break;
        case 14:
          if(t)
          {
#ifndef TEST_HARNESS
            query_status(task);
#endif
#ifdef TEST_HARNESS
            printf("Called query_status");
            putchar('\n');
#endif
            continue;
          }
          break;
        default:
          break;
      }
      /*
        The message does not contain a recognised AT command or response.
        Pass the data on to the application to have a go at 
      */
unrecognised:
#ifndef TEST_HARNESS
      handleUnrecognisedCmd(s, (uint16) (p-s), task);
#endif
#ifdef TEST_HARNESS
      printf("Called handleUnrecognisedCmd\n");
#endif
    }
  }

  return s;
}

static void SendOk(void)
{
    UartPrintf("\r\nOK\r\n");
}

static void SendError(void)
{
    UartPrintf("\r\nERROR\r\n");
}

static bool fill_bdaddr(bdaddr *addr,const struct sequence *src)
{
    uint8 c;
    uint16 i;

    if(src->length != 12)
        return FALSE;
    
    for( i = 0 ; i < src->length ; i++ )
    {
        c = (src->data)[i];
        
        if( c >= '0' && c <= '9' )
            c = c - '0';
        else if( c >= 'a' && c <= 'f' )
            c = c - 'a' + 10;
        else if( c >= 'A' && c <= 'F' )
            c = c - 'A' + 10;
        else
            return FALSE;
        
        if( i < 4 ) /* nap */
        {
            addr->nap <<= 4;
            addr->nap += c;
        }
        else if( i < 6 ) /* uap */
        {
            addr->uap <<= 4;
            addr->uap += c;
        }
        else /* lap */
        {
            addr->lap <<= 4;
            addr->lap += c;
        }
    }
    return TRUE;
}

/* handler functions */
void a2dp_signal_connect_req(Task task, const struct a2dp_signal_connect_req *req)
{
    bdaddr connect_bdaddr;
    if(fill_bdaddr(&connect_bdaddr,&req->bdaddr)){
        a2dpConnectBdaddrRequest(&connect_bdaddr,FALSE);
        SendOk();
    }else
        SendError();
}
void a2dp_signal_disconnect_req(Task task)
{
    a2dpDisconnectRequest();
}
void a2dp_start_req(Task task)
{
}
void a2dp_suspend_req(Task task)
{
}

static char *byte2str(uint8 uc)
{
    static char str[3];
    uint8 digit = (uc >> 4) & 0x0f;

    if(digit < 10)
        str[0] = '0' + digit;
    else 
        str[0] = 'A' + digit - 10;

    digit = uc & 0x0f;

    if(digit < 10)
        str[1] = '0' + digit;
    else 
        str[1] = 'A' + digit - 10;

    str[2] = 0;
    return str;    
}

void read_local_bdaddr(Task task)
{
    /* I will use this for remote addr */
	Sink sink = A2dpGetSignallingSink(theHeadset.a2dp);
	bdaddr addr;

	char *bdaddr_str = malloc(12 + 5 + 4 + 1);
	
 	if (bdaddr_str && sink && SinkGetBdAddr(sink, &addr) && !BdaddrIsZero(&addr))
 	{
 	    /* print nap */
 	    strcpy(bdaddr_str,"\r\n+RBD=");
 	    strcat(bdaddr_str,byte2str(addr.nap >> 8));
 	    strcat(bdaddr_str,byte2str(addr.nap & 0xFF));
 	    /* print uap */
 	    strcat(bdaddr_str,byte2str(addr.uap));
 	    /* print lap */
 	    strcat(bdaddr_str,byte2str((addr.lap >> 16) & 0xFF ));
 	    strcat(bdaddr_str,byte2str((addr.lap >> 8) & 0xFF));
 	    strcat(bdaddr_str,byte2str(addr.lap & 0xFF));
 	    strcat(bdaddr_str,"\r\n");
 	    UartPrintf(bdaddr_str);
 	}
 	else
        SendError();
    free(bdaddr_str);
}

void write_pin(Task task, const struct write_pin *pin)
{
}
void read_remote_name(Task task)
{
	Sink sink = A2dpGetSignallingSink(theHeadset.a2dp);
	bdaddr addr;
	
 	if (sink && SinkGetBdAddr(sink, &addr))
 	{
		ConnectionReadRemoteName(task, &addr);
		SendOk();
	}
	else
        SendError();
}

void write_local_name(Task task, const struct write_local_name *name)
{
    unsigned int i;
    unsigned int len = name->name.length/2 + (name->name.length % 2);
    uint16 *name_ptr = (uint16*)PanicUnlessMalloc(len);

    memset(name_ptr,0,len);
    for(i=0;i<name->name.length;i++){
        if(i%2){
            name_ptr[i/2] |= (name->name.data[i])<<8;
        }else{
            name_ptr[i/2] = name->name.data[i];
        }
    }
    WritePsKeys(PSKEY_DEVICE_NAME,name_ptr,len);
    free(name_ptr);
	SendOk();
}

void read_remote_rssi(Task task)
{
	Sink sink = A2dpGetSignallingSink(theHeadset.a2dp);

 	if (sink)
	{
		ConnectionGetRssi(task, sink);
	}
	else
		SendError();
}

void set_volume_speaker(Task task, const struct set_volume_speaker *vgs)
{
}

void set_volume_microphone(Task task, const struct set_volume_microphone *vgm)
{
}

void master_reset(Task task)
{
    ConnectionSmDeleteAllAuthDevices ( 0 );
	Panic();
}

void query_status(Task task)
{
    uint16 *pv = 0;
	SendEventHex(EVT_CONN_STATUS,*pv);
}

void set_scan_mode(Task task, const struct set_scan_mode *mode)
{
    if(mode->mode < 4)
    {
        ConnectionWriteScanEnable(mode->mode);
        SendOk();
    }else
        SendError();
    
}

void handleUnrecognisedCmd(const uint8 *data, uint16 length, Task task)
{
	SendError();
}

/* send command */

static const char * const gEventString[] =
{
	"+SCI",
	"+SCF",
	"+SDI",
	"+ACI",
	"+ACF",
	"+ADI",
	"CALL_STATE_INCOMING",
	"CALL_STATE_OUTGOING",
	"CALL_STATE_ACTIVE",
	"CALL_STATE_IDLE",
	"+MCI",
	"+MCF",
	"+MDI",
	"+MOI",
	"+MOF",
	"+MSI",
	"+MSF",
	"+MPI",
	"+MPF",
	"+CCI",
	"+CCF",
	"+CDI",
	"+CPL",
	"+CPS",
	"+CST",
	"+CFF",
	"+CFR",
	"+CFW",
	"+CRW",
	"+PCI",
	"+PCF",
	"+PDI",
	"+PBR",
	"PBAP_PULL_PHONEBOOK_REQ",
	"+PBS",
	"+PBC",
	"+SMS",
	"+STS"
};

void SendEvent(evt_string_id id,uint16 status)
{
	UartPrintf("\r\n%s=%d\r\n",gEventString[id],status);
}

void SendEventHex(evt_string_id id,uint16 status)
{
	UartPrintf("\r\n%s=%x\r\n",gEventString[id],status);
}

void SendData(uint8* data,uint16 length)
{
	uint16 i;
	for(i=0;i<length;i++)
		UartPrintf("%c",data[i]);
}

void SendHex(uint8* data,uint16 length)
{
	uint16 i;
	for(i=0;i<length;i++)
	{
		if(data[i]<0x10)
			UartPrintf("0%x",data[i]);
		else
			UartPrintf("%x",data[i]);
	}
}

